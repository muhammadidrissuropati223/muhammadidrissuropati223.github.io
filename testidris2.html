<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Consent-based IP test (client)</title>
  <style>
    body{font-family:Arial,sans-serif;padding:16px}
    input,button{display:block;width:100%;margin:8px 0;padding:8px}
    #note{font-size:13px;color:#444}
    .row{display:flex;gap:8px;align-items:center}
    .row > *{flex:1}
    .muted{font-size:12px;color:#666;margin-top:-6px}
  </style>
</head>
<body>
  <h3>Demo pengiriman event (dengan persetujuan)</h3>

  <label><input type="checkbox" id="consent"> Saya setuju data demo dikirim ke server</label>

  <div class="row">
    <input id="address" type="text" placeholder="Ketik alamat (opsional)" autocomplete="street-address" />
    <button id="getIPBtn" type="button" disabled>Ambil IP</button>
  </div>
  <div class="muted">Server akan menerima request dan dapat melihat IP dari koneksi. Tombol "Ambil IP" menanyakan IP publik Anda dari layanan pihak ketiga (opsional) setelah ada persetujuan.</div>

  <div id="note" class="muted">Pastikan koneksi internet aktif untuk mendapatkan IP publik dari layanan eksternal.</div>

  <div id="out" aria-live="polite" style="margin-top:12px;font-weight:bold">Address: </div>
  <div id="ipOut" aria-live="polite" class="muted">IP: (belum diambil)</div>

  <script>
    // =======================
    // KONFIGURASI
    // =======================
    // GANTI dengan endpoint devmu atau webhook.site
    const ENDPOINT = 'https://your-server.example.com/collect'; // or webhook.site URL

    // =======================
    // ELEMEN DOM
    // =======================
    const consent = document.getElementById('consent');
    const input = document.getElementById('address');
    const out = document.getElementById('out');
    const ipOut = document.getElementById('ipOut');
    const getIPBtn = document.getElementById('getIPBtn');

    // State IP yang didapat
    let currentIP = null;
    let currentIPSource = null;

    function updateOutput(v){ out.textContent = 'Address: ' + v; }
    function updateIPOutput(ip, src){
      ipOut.textContent = ip ? `IP: ${ip} (sumber: ${src})` : 'IP: (belum diambil)';
    }

    // =======================
    // UTIL: timeout fetch
    // =======================
    async function fetchWithTimeout(url, opts = {}, ms = 4000){
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), ms);
      try {
        const res = await fetch(url, { ...opts, signal: controller.signal });
        return res;
      } finally {
        clearTimeout(id);
      }
    }

    // =======================
    // DAPATKAN IP PUBLIK (multi-strategy)
    // =======================
    async function getPublicIP(){
      // 1) ipify
      try {
        const r = await fetchWithTimeout('https://api.ipify.org?format=json', { mode: 'cors', cache: 'no-store' }, 4000);
        if (r.ok){
          const j = await r.json();
          if (j && j.ip){
            return { ip: j.ip, source: 'ipify' };
          }
        }
      } catch(_) {}

      // 2) Cloudflare trace
      try {
        const r = await fetchWithTimeout('https://www.cloudflare.com/cdn-cgi/trace', { mode: 'cors', cache: 'no-store' }, 4000);
        if (r.ok){
          const t = await r.text();
          // format: key=value\n ... ip=1.2.3.4 ...
          const m = t.match(/(?:^|\n)ip=([^\n]+)/);
          if (m && m[1]) return { ip: m[1].trim(), source: 'cloudflare-trace' };
        }
      } catch(_) {}

      // 3) WebRTC STUN (mungkin ter-mask/mDNS; coba tangkap srflx/public)
      try {
        const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        // Chrome/Firefox modern: perlu data channel agar ICE jalan
        pc.createDataChannel('ip-test');
        const candIPs = new Set();
        pc.onicecandidate = (e) => {
          if (!e.candidate) return;
          const c = e.candidate.candidate;
          // Contoh candidate line: candidate:... typ srflx raddr ... rport ...
          const srflx = / typ srflx /i.test(c);
          const ipMatch = c.match(/((?:\d{1,3}\.){3}\d{1,3})/); // IPv4
          if (srflx && ipMatch){
            candIPs.add(ipMatch[1]);
          }
        };
        await pc.setLocalDescription(await pc.createOffer());
        // Tunggu sebentar kumpulkan candidate
        await new Promise(res => setTimeout(res, 1200));
        pc.close();
        if (candIPs.size){
          // Ambil yang pertama
          return { ip: Array.from(candIPs)[0], source: 'webrtc-stun' };
        }
      } catch(_) {}

      throw new Error('Gagal mendapatkan IP publik dari semua metode');
    }

    // =======================
    // Build minimal payload
    // =======================
    function buildPayload(v){
      return {
        addressHint: (v||'').slice(0,200),
        ts: new Date().toISOString(),
        ua: navigator.userAgent,
        page: location.href,
        ip: currentIP || null,
        ipSource: currentIPSource || null
      };
    }

    // =======================
    // send: prefer sendBeacon, fallback fetch, fallback XHR
    // =======================
    function sendPayload(payload){
      const json = JSON.stringify(payload);

      // 1) sendBeacon
      if (navigator && navigator.sendBeacon){
        try {
          const blob = new Blob([json], { type: 'application/json' });
          const ok = navigator.sendBeacon(ENDPOINT, blob);
          if (ok) return; // sent
        } catch (e) { /* fallback */ }
      }

      // 2) fetch with keepalive
      if (window.fetch){
        try {
          fetch(ENDPOINT, {
            method:'POST',
            headers: {'Content-Type':'application/json'},
            body: json,
            keepalive: true,
            mode: 'cors'
          }).catch(()=>{});
          return;
        } catch(e){}
      }

      // 3) XHR fallback (older browsers)
      try {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', ENDPOINT, true);
        xhr.setRequestHeader('Content-Type','application/json');
        xhr.send(json);
      } catch(e){}
    }

    // =======================
    // THROTTLE input ke 1 per 1500ms
    // =======================
    let last = 0;
    input.addEventListener('input', function(){
      updateOutput(this.value || '');
      if (!consent.checked) return;
      const now = Date.now();
      if (now - last < 1500) return;
      last = now;
      sendPayload(buildPayload(this.value || ''));
    });

    // =======================
    // PERILAKU: persetujuan & tombol IP
    // =======================
    consent.addEventListener('change', async function(){
      getIPBtn.disabled = !this.checked;
      if (!this.checked) {
        currentIP = null;
        currentIPSource = null;
        updateIPOutput(null, null);
        return;
      }
      // Ambil IP otomatis saat consent dicentang (boleh dimatikan jika mau manual)
      getIPBtn.textContent = 'Mengambil IP...';
      try {
        const { ip, source } = await getPublicIP();
        currentIP = ip; currentIPSource = source;
        updateIPOutput(ip, source);
      } catch (e){
