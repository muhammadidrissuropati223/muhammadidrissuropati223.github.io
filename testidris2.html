<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Login — Kirim Lokasi (dengan persetujuan)</title>
  <meta name="description" content="Demo login yang meminta persetujuan dan mengirim lokasi saat login.">

  <style>
    :root{--maxw:520px;--muted:#666}
    body{font-family:Inter,system-ui,Arial,sans-serif;display:flex;align-items:center;justify-content:center;min-height:100vh;margin:0;padding:24px;background:#f7fafc}
    .card{width:100%;max-width:var(--maxw);background:#fff;border-radius:10px;box-shadow:0 6px 18px rgba(27,31,35,0.08);padding:20px}
    h1{margin:0 0 8px;font-size:20px}
    p.lead{margin:0 0 16px;color:var(--muted);font-size:13px}
    label{display:block;margin:10px 0 4px;font-size:13px}
    input[type="text"],input[type="password"]{width:100%;padding:10px;border:1px solid #e6e9ef;border-radius:8px;box-sizing:border-box}
    .row{display:flex;gap:8px}
    button{padding:10px;border-radius:8px;border:0;background:#0b74de;color:#fff;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.6;cursor:not-allowed}
    .muted{color:var(--muted);font-size:13px}
    .status{margin-top:12px;font-size:13px}
    .danger{color:#b91c1c}
    .success{color:#065f46}
    .small{font-size:12px;color:var(--muted);margin-top:8px}
  </style>
</head>
<body>
  <div class="card" role="main">
    <h1>Masuk</h1>
    <p class="lead">Masuk untuk melanjutkan. Lokasi akan dikirim hanya jika Anda memberi persetujuan.</p>

    <form id="loginForm" autocomplete="on">
      <label for="username">Username</label>
      <input id="username" name="username" type="text" required autocomplete="username" />

      <label for="password">Password</label>
      <input id="password" name="password" type="password" required autocomplete="current-password" />

      <label style="margin-top:12px">
        <input id="consent" type="checkbox" />
        Saya memberi persetujuan agar lokasi (geolocation) dikirim ke server saat login.
      </label>
      <div class="small">Lokasi adalah data sensitif — pastikan Anda memiliki izin pengguna. Halaman ini meminta lokasi hanya setelah persetujuan.</div>

      <div style="margin-top:14px" class="row">
        <button id="loginBtn" type="submit">Login</button>
      </div>
    </form>

    <div id="status" class="status muted" aria-live="polite"></div>
    <div id="debug" class="small"></div>
  </div>

  <script>
    // =======================
    // KONFIGURASI: GANTI sesuai kebutuhan
    // =======================
    // Endpoint server yang akan menerima payload login
    // contoh: 'https://webhook.site/xxxx' atau endpoint dev Anda
    const ENDPOINT = 'https://your-server.example.com/login';

    // Jika true -> kirimkan juga IP publik (melalui layanan eksternal)
    // Catatan: aktifkan hanya jika Anda paham implikasi privasinya.
    const TRY_FETCH_PUBLIC_IP = false;

    // =======================
    // Helper UI
    // =======================
    const form = document.getElementById('loginForm');
    const loginBtn = document.getElementById('loginBtn');
    const consent = document.getElementById('consent');
    const statusEl = document.getElementById('status');
    const debugEl = document.getElementById('debug');

    function setStatus(text, kind) {
      statusEl.textContent = text;
      statusEl.className = 'status' + (kind ? ' ' + kind : '');
    }
    function debug(...args) {
      debugEl.textContent = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
    }

    // =======================
    // Fungsi pengiriman payload: sendBeacon -> fetch -> XHR
    // =======================
    function sendPayload(payload) {
      const json = JSON.stringify(payload);
      // Prefer sendBeacon for reliability on unload
      if (navigator && navigator.sendBeacon) {
        try {
          const blob = new Blob([json], { type: 'application/json' });
          const ok = navigator.sendBeacon(ENDPOINT, blob);
          if (ok) {
            debug('sendBeacon ok');
            return Promise.resolve({ sentBy: 'sendBeacon' });
          }
        } catch (e) {
          console.warn('sendBeacon failed', e);
        }
      }

      // Fallback fetch
      if (window.fetch) {
        return fetch(ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: json,
          keepalive: true,
          mode: 'cors'
        })
        .then(res => ({ sentBy: 'fetch', status: res.status }))
        .catch(err => {
          console.warn('fetch failed', err);
          // fallback to XHR
          return new Promise((resolve) => {
            try {
              const xhr = new XMLHttpRequest();
              xhr.open('POST', ENDPOINT, true);
              xhr.setRequestHeader('Content-Type', 'application/json');
              xhr.onload = () => resolve({ sentBy: 'xhr', status: xhr.status });
              xhr.onerror = () => resolve({ sentBy: 'xhr', status: 0 });
              xhr.send(json);
            } catch (e) {
              console.error('XHR failed', e);
              resolve({ sentBy: 'none' });
            }
          });
        });
      }

      // Final fallback: XHR synchronous-ish attempt
      return new Promise((resolve) => {
        try {
          const xhr = new XMLHttpRequest();
          xhr.open('POST', ENDPOINT, true);
          xhr.setRequestHeader('Content-Type', 'application/json');
          xhr.onload = () => resolve({ sentBy: 'xhr', status: xhr.status });
          xhr.onerror = () => resolve({ sentBy: 'xhr', status: 0 });
          xhr.send(json);
        } catch (e) {
          console.error('final XHR failed', e);
          resolve({ sentBy: 'none' });
        }
      });
    }

    // =======================
    // Ambil IP publik (opsional)
    // =======================
    async function fetchPublicIP() {
      try {
        const res = await fetch('https://api.ipify.org?format=json', { cache: 'no-store' });
        if (res.ok) {
          const j = await res.json();
          return j.ip;
        }
      } catch (e) {
        console.warn('fetchPublicIP failed', e);
      }
      return null;
    }

    // =======================
    // Main submit handler
    // =======================
    form.addEventListener('submit', async function (ev) {
      ev.preventDefault();
      setStatus('', '');
      loginBtn.disabled = true;
      setStatus('Memproses login...', '');

      const username = (document.getElementById('username').value || '').trim();
      const password = (document.getElementById('password').value || '');

      // Basic UI validation
      if (!username || !password) {
        setStatus('Masukkan username dan password.', 'danger');
        loginBtn.disabled = false;
        return;
      }

      // Build minimal payload
      const basePayload = {
        username,
        ts: new Date().toISOString(),
        ua: navigator.userAgent,
        page: location.href,
      };

      // If user gave consent, request geolocation
      if (consent.checked && 'geolocation' in navigator) {
        setStatus('Meminta izin lokasi dari browser...', '');
        // Options: highAccuracy false by default (tweak if perlu)
        const geoOptions = { enableHighAccuracy: false, timeout: 10000, maximumAge: 60 * 1000 };

        const getPosition = () => new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, geoOptions);
        });

        try {
          const pos = await getPosition();
          const coords = pos.coords;
          basePayload.location = {
            latitude: coords.latitude,
            longitude: coords.longitude,
            accuracy: coords.accuracy,
            altitude: coords.altitude,
            altitudeAccuracy: coords.altitudeAccuracy,
            heading: coords.heading,
            speed: coords.speed,
            timestamp: pos.timestamp
          };
          setStatus('Lokasi diperoleh, mengirim data...', ''); 
        } catch (err) {
          // User denied or error; still continue but without location
          console.warn('Geolocation error:', err);
          setStatus('Izin lokasi ditolak/terjadi error. Mengirim login tanpa lokasi.', 'danger');
        }
      } else if (consent.checked && !('geolocation' in navigator)) {
        setStatus('Browser tidak mendukung Geolocation API. Mengirim login tanpa lokasi.', 'danger');
      } else {
        setStatus('Persetujuan lokasi tidak diberikan. Mengirim login tanpa lokasi.', 'muted');
      }

      // Optional: attach public IP (toggle di atas)
      if (TRY_FETCH_PUBLIC_IP) {
        setStatus('Mencoba mengambil IP publik (opsional)...', '');
        try {
          const ip = await fetchPublicIP();
          if (ip) basePayload.publicIp = ip;
        } catch (e) { /* ignore */ }
      }

      // Finally, send payload
      try {
        const res = await sendPayload(basePayload);
        debug('payload', basePayload, 'result', res);
        setStatus('Login terkirim. Respon: ' + (res && res.status ? res.status : res.sentBy || 'ok'), 'success');
      } catch (e) {
        console.error(e);
        setStatus('Gagal mengirim data. Cek console.', 'danger');
      } finally {
        loginBtn.disabled = false;
      }
    });

    // Optional: send final beacon on unload if user is consented and has location saved in session
    // (This is a minimal best-effort; not required)
    window.addEventListener('beforeunload', function () {
      // If you want to attempt to send something on unload, implement here.
      // Note: getCurrentPosition is not available in unload; only sendBeacon works reliably.
    });
  </script>
</body>
</html>
