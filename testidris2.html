<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Consent-based IP Test (Client)</title>

  <!--
    Project: Consent-based IP Test
    Author: Muhammad Idris
    License: MIT
    Description:
      Demo untuk pengiriman event berbasis persetujuan (consent).
      - Hanya mengirim data jika pengguna menyetujui.
      - Dapat mengambil IP publik dari layanan eksternal (ipify, Cloudflare, WebRTC STUN).
      - Mengirim payload JSON minimal ke endpoint server.
  -->

  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 16px;
      line-height: 1.5;
    }
    input, button {
      display: block;
      width: 100%;
      margin: 8px 0;
      padding: 8px;
      box-sizing: border-box;
    }
    #note { font-size: 13px; color: #444; }
    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }
    .muted { font-size: 12px; color: #666; margin-top: -6px; }
  </style>
</head>
<body>
  <h3>Demo Pengiriman Event (dengan Persetujuan)</h3>

  <label><input type="checkbox" id="consent"> Saya setuju data demo dikirim ke server</label>

  <div class="row">
    <input id="address" type="text" placeholder="Ketik alamat (opsional)" autocomplete="street-address" />
    <button id="getIPBtn" type="button" disabled>Ambil IP</button>
  </div>

  <div class="muted">
    Server akan menerima request dan dapat melihat IP dari koneksi.
    Tombol "Ambil IP" menanyakan IP publik Anda dari layanan pihak ketiga (opsional) setelah ada persetujuan.
  </div>

  <div id="note" class="muted">
    Pastikan koneksi internet aktif untuk mendapatkan IP publik dari layanan eksternal.
  </div>

  <div id="out" aria-live="polite" style="margin-top:12px;font-weight:bold">Address: </div>
  <div id="ipOut" aria-live="polite" class="muted">IP: (belum diambil)</div>

  <script>
    // =======================
    // KONFIGURASI
    // =======================
    // Ganti dengan endpoint server Anda (contoh: webhook.site)
    const ENDPOINT = 'https://your-server.example.com/collect';

    // =======================
    // ELEMEN DOM
    // =======================
    const consent = document.getElementById('consent');
    const input = document.getElementById('address');
    const out = document.getElementById('out');
    const ipOut = document.getElementById('ipOut');
    const getIPBtn = document.getElementById('getIPBtn');

    // State IP yang didapat
    let currentIP = null;
    let currentIPSource = null;

    // =======================
    // FUNGSI BANTUAN
    // =======================
    function updateOutput(v) {
      out.textContent = 'Address: ' + v;
    }

    function updateIPOutput(ip, src) {
      ipOut.textContent = ip ? `IP: ${ip} (sumber: ${src})` : 'IP: (belum diambil)';
    }

    async function fetchWithTimeout(url, opts = {}, ms = 4000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), ms);
      try {
        const res = await fetch(url, { ...opts, signal: controller.signal });
        return res;
      } finally {
        clearTimeout(id);
      }
    }

    // =======================
    // DAPATKAN IP PUBLIK
    // =======================
    async function getPublicIP() {
      try {
        const r = await fetchWithTimeout('https://api.ipify.org?format=json', { mode: 'cors', cache: 'no-store' }, 4000);
        if (r.ok) {
          const j = await r.json();
          if (j && j.ip) return { ip: j.ip, source: 'ipify' };
        }
      } catch (_) {}

      try {
        const r = await fetchWithTimeout('https://www.cloudflare.com/cdn-cgi/trace', { mode: 'cors', cache: 'no-store' }, 4000);
        if (r.ok) {
          const t = await r.text();
          const m = t.match(/(?:^|\n)ip=([^\n]+)/);
          if (m && m[1]) return { ip: m[1].trim(), source: 'cloudflare-trace' };
        }
      } catch (_) {}

      try {
        const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        pc.createDataChannel('ip-test');
        const candIPs = new Set();
        pc.onicecandidate = (e) => {
          if (!e.candidate) return;
          const c = e.candidate.candidate;
          const srflx = / typ srflx /i.test(c);
          const ipMatch = c.match(/((?:\d{1,3}\.){3}\d{1,3})/);
          if (srflx && ipMatch) candIPs.add(ipMatch[1]);
        };
        await pc.setLocalDescription(await pc.createOffer());
        await new Promise(res => setTimeout(res, 1200));
        pc.close();
        if (candIPs.size) return { ip: Array.from(candIPs)[0], source: 'webrtc-stun' };
      } catch (_) {}

      throw new Error('Gagal mendapatkan IP publik dari semua metode');
    }

    // =======================
    // PAYLOAD & PENGIRIMAN
    // =======================
    function buildPayload(v) {
      return {
        addressHint: (v || '').slice(0, 200),
        ts: new Date().toISOString(),
        ua: navigator.userAgent,
        page: location.href,
        ip: currentIP || null,
        ipSource: currentIPSource || null
      };
    }

    function sendPayload(payload) {
      const json = JSON.stringify(payload);
      if (navigator && navigator.sendBeacon) {
        try {
          const blob = new Blob([json], { type: 'application/json' });
          const ok = navigator.sendBeacon(ENDPOINT, blob);
          if (ok) return;
        } catch (_) {}
      }
      if (window.fetch) {
        try {
          fetch(ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: json,
            keepalive: true,
            mode: 'cors'
          }).catch(() => {});
          return;
        } catch (_) {}
      }
      try {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', ENDPOINT, true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(json);
      } catch (_) {}
    }

    // =======================
    // EVENT HANDLERS
    // =======================
    let last = 0;
    input.addEventListener('input', function() {
      updateOutput(this.value || '');
      if (!consent.checked) return;
      const now = Date.now();
      if (now - last < 1500) return;
      last = now;
      sendPayload(buildPayload(this.value || ''));
    });

    consent.addEventListener('change', async function() {
      getIPBtn.disabled = !this.checked;
      if (!this.checked) {
        currentIP = null;
        currentIPSource = null;
        updateIPOutput(null, null);
        return;
      }
      getIPBtn.textContent = 'Mengambil IP...';
      try {
        const { ip, source } = await getPublicIP();
        currentIP = ip; currentIPSource = source;
        updateIPOutput(ip, source);
      } catch (e) {
        updateIPOutput(null, null);
        console.warn(e);
      } finally {
        getIPBtn.textContent = 'Ambil IP';
      }
    });

    getIPBtn.addEventListener('click', async function() {
      if (!consent.checked) return;
      this.textContent = 'Mengambil IP...';
      this.disabled = true;
      try {
        const { ip, source } = await getPublicIP();
        currentIP = ip; currentIPSource = source;
        updateIPOutput(ip, source);
        sendPayload(buildPayload(input.value || ''));
      } catch (e) {
        console.warn(e);
        updateIPOutput(null, null);
      } finally {
        this.textContent = 'Ambil IP';
        this.disabled = !consent.checked;
      }
    });

    window.addEventListener('beforeunload', function() {
      if (!consent.checked) return;
      const payload = buildPayload(input.value || '');
      try {
        navigator.sendBeacon(ENDPOINT, new Blob([JSON.stringify(payload)], { type: 'application/json' }));
      } catch (_) {}
    });

    // Init UI
    updateOutput('');
    updateIPOutput(null, null);
  </script>
</body>
</html>
